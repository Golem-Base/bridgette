package webui

import (
	"fmt"
	"time"
)

// Helper function to prefix URLs with pathPrefix
func prefixURL(pathPrefix, url string) string {
	if pathPrefix == "" {
		return url
	}
	// Ensure pathPrefix starts with / but doesn't end with /
	prefix := pathPrefix
	if prefix[0] != '/' {
		prefix = "/" + prefix
	}
	if prefix[len(prefix)-1] == '/' {
		prefix = prefix[:len(prefix)-1]
	}
	return prefix + url
}

css wavesLeftBg(pathPrefix string) {
	background-image: { templ.SafeCSSProperty("url('" + prefixURL(pathPrefix, "/static/img/waves_left.svg") + "')") };
}

css wavesRightBg(pathPrefix string) {
	background-image: { templ.SafeCSSProperty("url('" + prefixURL(pathPrefix, "/static/img/waves_right.svg") + "')") };
}

css linesOverlayBg(pathPrefix string) {
	background-image: { templ.SafeCSSProperty("url('" + prefixURL(pathPrefix, "/static/img/lines.svg") + "')") };
}

css networkBg(pathPrefix string) {
	background: { templ.SafeCSSProperty("url('" + prefixURL(pathPrefix, "/static/img/bg.webp") + "')") };
	background-size: cover;
	background-position: center;
	background-repeat: no-repeat;
	position: relative;
	min-height: 100vh;
}

templ Layout(title string, pathPrefix string) {
	<!DOCTYPE html>
	<html lang="en">
		<head>
			<meta charset="UTF-8"/>
			<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
			<title>{ title } - Golem Bridge Monitor</title>
			<script src={ prefixURL(pathPrefix, "/static/js/htmx.min.js") }></script>
			<script src={ prefixURL(pathPrefix, "/static/js/morphdom.min.js") }></script>
			<script src={ prefixURL(pathPrefix, "/static/js/morphdom-swap.js") }></script>
			<script src={ prefixURL(pathPrefix, "/static/js/tailwind.min.js") }></script>
			<style>
				:root {
					--golem-blue-dark: #1e3a8a;
					--golem-blue: #3b82f6;
					--golem-blue-light: #60a5fa;
					--golem-accent: #1e40af;
				}
				
				body {
					font-family: ui-sans-serif, system-ui, sans-serif;
					color: white;
					min-height: 100vh;
					position: relative;
				}
				


				
				.waves-left {
					position: fixed;
					top: 0;
					left: 0;
					z-index: 0;
					max-height: 100%;
					background-repeat: no-repeat;
					background-size: auto 100vh;
					background-position: left top;
					width: 40vw;
					max-width: 50vw;
					height: 100vh;
					pointer-events: none;
					animation: float-left 20s ease-in-out infinite;
					overflow: hidden;
				}
				
				.waves-right {
					position: fixed;
					top: 0;
					right: 0;
					z-index: 0;
					max-height: 100%;
					background-repeat: no-repeat;
					background-size: auto 100vh;
					background-position: right top;
					width: 40vw;
					max-width: 50vw;
					height: 100vh;
					pointer-events: none;
					animation: float-right 20s ease-in-out infinite;
					overflow: hidden;
				}
				
				.lines-overlay {
					position: fixed;
					top: 0;
					right: 0;
					z-index: 0;
					max-height: 100%;
					background-repeat: no-repeat;
					background-size: auto 100vh;
					background-position: right top;
					width: 40vw;
					max-width: 50vw;
					height: 100vh;
					pointer-events: none;
					opacity: 0.7;
				}
				
				@keyframes float-left {
					0%, 100% { transform: translateY(0px) translateX(0px); }
					25% { transform: translateY(-10px) translateX(5px); }
					50% { transform: translateY(0px) translateX(-5px); }
					75% { transform: translateY(5px) translateX(10px); }
				}
				
				@keyframes float-right {
					0%, 100% { transform: translateY(0px) translateX(0px); }
					25% { transform: translateY(10px) translateX(-5px); }
					50% { transform: translateY(0px) translateX(5px); }
					75% { transform: translateY(-5px) translateX(-10px); }
				}
				
				header,
				main,
				footer {
					position: relative;
					z-index: 10;
				}
				
				.golem-header {
					background: rgba(0, 0, 0, 0.1);
					backdrop-filter: blur(10px);
					border-bottom: 1px solid rgba(255, 255, 255, 0.2);
					color: white;
				}
				
				.golem-button {
					background: rgba(255, 255, 255, 0.2);
					color: white;
					border-radius: 0.5rem;
					padding: 0.75rem 1.5rem;
					font-weight: 600;
					transition: all 0.2s;
					border: 1px solid rgba(255, 255, 255, 0.3);
					backdrop-filter: blur(10px);
				}
				
				.golem-button:hover {
					background: rgba(255, 255, 255, 0.3);
					border-color: rgba(255, 255, 255, 0.5);
				}
				
				.golem-card {
					background: rgba(255, 255, 255, 0.1);
					backdrop-filter: blur(15px);
					border: 1px solid rgba(255, 255, 255, 0.2);
					border-radius: 1rem;
					box-shadow: 0 8px 32px 0 rgba(31, 38, 135, 0.37);
					padding: 2rem;
					color: white;
				}
				
				.timeline-item {
					border-left: 2px solid rgba(255, 255, 255, 0.3);
					padding-left: 1.5rem;
					padding-bottom: 2rem;
					position: relative;
				}
				
				.timeline-item::before {
					content: '';
					position: absolute;
					left: -8px;
					top: 0;
					height: 14px;
					width: 14px;
					background: rgba(255, 255, 255, 0.8);
					border-radius: 50%;
					box-shadow: 0 0 10px rgba(255, 255, 255, 0.5);
				}
				
				.timeline-container {
					margin-left: 1rem;
				}
				
				.status-waiting {
					background: rgba(245, 158, 11, 0.2);
					border: 1px solid rgba(245, 158, 11, 0.4);
					color: #fbbf24;
				}
				
				.status-completed {
					background: rgba(34, 197, 94, 0.2);
					border: 1px solid rgba(34, 197, 94, 0.4);
					color: #4ade80;
				}
				
				.metric-card {
					background: rgba(255, 255, 255, 0.15);
					backdrop-filter: blur(10px);
					border: 1px solid rgba(255, 255, 255, 0.25);
					border-radius: 0.75rem;
					padding: 1.5rem;
					color: white;
				}
				
				.metric-value {
					font-size: 2rem;
					font-weight: bold;
					color: white;
				}
				
				.metric-label {
					color: rgba(255, 255, 255, 0.8);
					font-size: 1.125rem;
					font-weight: 600;
				}
				
				.text-amber-600 {
					color: #fbbf24 !important;
				}
				
				.text-gray-500 {
					color: rgba(255, 255, 255, 0.6) !important;
				}
				
				.text-gray-600 {
					color: rgba(255, 255, 255, 0.7) !important;
				}
				
				.text-blue-600 {
					color: #60a5fa !important;
				}
				
				.border-amber-500 {
					border-color: #fbbf24 !important;
				}
			</style>
		</head>
		<body class={ "text-white min-h-screen", networkBg(pathPrefix) } hx-ext="morphdom-swap">
			<div class={ "waves-left", wavesLeftBg(pathPrefix) }></div>
			<div class={ "waves-right", wavesRightBg(pathPrefix) }></div>
			<div class={ "lines-overlay", linesOverlayBg(pathPrefix) }></div>
			
			<header class="golem-header py-6">
				<div class="container mx-auto px-4">
					<div class="flex items-center justify-between">
						<div class="flex items-center">
							<h1 class="text-3xl font-bold text-white">Golem Bridge Monitor</h1>
						</div>
					</div>
				</div>
			</header>
			
			<main class="container mx-auto px-4 py-8">
				{ children... }
			</main>
			
			<footer class="py-6 mt-12 border-t border-white/20 bg-black/10 backdrop-blur-sm">
				<div class="container mx-auto px-4">
					<p class="text-center text-white/80">Â© { time.Now().Year() } Golem Base. All rights reserved.</p>
				</div>
			</footer>
		</body>
	</html>
}

// Dashboard is the main page template
templ Dashboard(pathPrefix string) {
	@Layout("Dashboard", pathPrefix) {
		<div class="space-y-8">
			<div id="dashboard-metrics" hx-get={ prefixURL(pathPrefix, "/dashboard/metrics") } hx-trigger="load"></div>
			<div id="bridge-performance" hx-get={ prefixURL(pathPrefix, "/dashboard/performance") } hx-trigger="load"></div>
			<div>
				@TimeSeriesChart(pathPrefix)
			</div>
			<div id="unmatched-deposits-section" hx-get={ prefixURL(pathPrefix, "/dashboard/unmatched") } hx-trigger="load"></div>
			<div id="deposits-timeline-section" hx-get={ prefixURL(pathPrefix, "/dashboard/timeline") } hx-trigger="load"></div>
		</div>
	}
}

// DashboardMetrics contains the metrics cards
templ DashboardMetrics(stats map[string]interface{}, pathPrefix string) {
	<div hx-get={ prefixURL(pathPrefix, "/dashboard/metrics") } hx-trigger="every 2s" hx-swap="morphdom" hx-swap="outerHTML">
		<div class="grid grid-cols-1 md:grid-cols-3 gap-6 mb-8">
			<div class="metric-card">
				<h3 class="metric-label mb-3">Total Matched Deposits</h3>
				<p class="metric-value">{ fmt.Sprintf("%d", stats["total_matched"].(int)) }</p>
			</div>
			<div class="metric-card">
				<h3 class="metric-label mb-3">Average Confirmation Time</h3>
				<p class="metric-value">{ fmt.Sprintf("%.1f sec", stats["avg_time_diff"].(float64)) }</p>
			</div>
			<div class="metric-card">
				<h3 class="metric-label mb-3">Total Bridged ETH</h3>
				<p class="metric-value">{ fmt.Sprintf("%.4f ETH", stats["total_bridged_eth"].(float64)) }</p>
			</div>
		</div>
		<div class="grid grid-cols-1 md:grid-cols-3 gap-6">
			<div class="metric-card border-2 border-amber-500/50">
				<h3 class="metric-label mb-3 text-amber-400">Unmatched Deposits</h3>
				<p class="metric-value text-amber-300">{ fmt.Sprintf("%d", stats["pending_deposits"].(int)) }</p>
			</div>
			<div class="metric-card">
				<h2 class="text-xl font-bold mb-4 text-white">Latest L1 Block</h2>
				<div class="grid grid-cols-2 gap-4">
					<div>
						<h4 class="text-sm font-medium text-white/60 mb-1">Block Number</h4>
						<p class="text-lg font-semibold text-white">{ fmt.Sprintf("%d", stats["latest_l1_block"].(int)) }</p>
					</div>
					<div>
						<h4 class="text-sm font-medium text-white/60 mb-1">Time Since</h4>
						<p class="text-lg font-semibold text-white">{ fmt.Sprintf("%.1f sec", stats["l1_time_since"].(float64)) }</p>
					</div>
				</div>
			</div>
			<div class="metric-card">
				<h2 class="text-xl font-bold mb-4 text-white">Latest L2 Block</h2>
				<div class="grid grid-cols-2 gap-4">
					<div>
						<h4 class="text-sm font-medium text-white/60 mb-1">Block Number</h4>
						<p class="text-lg font-semibold text-white">{ fmt.Sprintf("%d", stats["latest_l2_block"].(int)) }</p>
					</div>
					<div>
						<h4 class="text-sm font-medium text-white/60 mb-1">Time Since</h4>
						<p class="text-lg font-semibold text-white">{ fmt.Sprintf("%.1f sec", stats["l2_time_since"].(float64)) }</p>
					</div>
				</div>
			</div>
		</div>
	</div>
}

// BridgePerformance contains the bridge performance stats
templ BridgePerformance(stats map[string]interface{}, pathPrefix string) {
	<div class="golem-card" hx-get={ prefixURL(pathPrefix, "/dashboard/performance") } hx-trigger="every 3s" hx-swap="morphdom" hx-swap="outerHTML">
		<h2 class="text-xl font-bold mb-4">Bridge Performance</h2>
		<div class="grid grid-cols-1 md:grid-cols-3 gap-4">
			<div>
				<h4 class="text-sm font-medium text-gray-500">Minimum Time</h4>
				<p class="text-lg font-semibold">{ fmt.Sprintf("%.1f sec", stats["min_time_diff"].(float64)) }</p>
			</div>
			<div>
				<h4 class="text-sm font-medium text-gray-500">Average Time</h4>
				<p class="text-lg font-semibold">{ fmt.Sprintf("%.1f sec", stats["avg_time_diff"].(float64)) }</p>
			</div>
			<div>
				<h4 class="text-sm font-medium text-gray-500">Maximum Time</h4>
				<p class="text-lg font-semibold">{ fmt.Sprintf("%.1f sec", stats["max_time_diff"].(float64)) }</p>
			</div>
		</div>
	</div>
}

// UnmatchedDepositsSection contains the unmatched deposits section
templ UnmatchedDepositsSection(deposits []UnmatchedDeposit, page, totalPages int, pathPrefix string) {
	<div class="golem-card" hx-get={ prefixURL(pathPrefix, fmt.Sprintf("/dashboard/unmatched?page=%d", page)) } hx-trigger="every 2s" hx-swap="morphdom" hx-swap="outerHTML">
		<div class="mb-6">
			<h2 class="text-xl font-bold text-amber-600">Unmatched Deposits</h2>
			<p class="text-sm text-gray-600">Deposits waiting for L2 confirmation</p>
		</div>
		<div class="timeline-container">
			if len(deposits) == 0 {
				<p class="text-center py-6 text-gray-500">No unmatched deposits found</p>
			} else {
				for _, deposit := range deposits {
					@UnmatchedDepositItem(deposit)
				}
			}
		</div>
		if totalPages > 1 {
			<div class="flex justify-between items-center mt-6">
				<div>
					<span class="text-sm text-gray-600">Page { fmt.Sprintf("%d of %d", page, totalPages) }</span>
				</div>
				<div class="flex space-x-2">
					if page > 1 {
						<button
							class="golem-button"
							hx-get={ prefixURL(pathPrefix, fmt.Sprintf("/dashboard/unmatched?page=%d", page-1)) }
							hx-target="closest .golem-card"
							hx-swap="morphdom"
						>
							Previous
						</button>
					}
					if page < totalPages {
						<button
							class="golem-button"
							hx-get={ prefixURL(pathPrefix, fmt.Sprintf("/dashboard/unmatched?page=%d", page+1)) }
							hx-target="closest .golem-card"
							hx-swap="morphdom"
						>
							Next
						</button>
					}
				</div>
			</div>
		}
	</div>
}

// DepositsTimelineSection contains the deposits timeline section
templ DepositsTimelineSection(deposits []DepositPair, page, totalPages int, pathPrefix string) {
	<div class="golem-card" hx-get={ prefixURL(pathPrefix, fmt.Sprintf("/dashboard/timeline?page=%d", page)) } hx-trigger="every 5s" hx-swap="morphdom" hx-swap="outerHTML">
		<div class="mb-6">
			<h2 class="text-xl font-bold">Deposit Timeline</h2>
		</div>
		<div class="timeline-container">
			if len(deposits) == 0 {
				<p class="text-center py-6 text-gray-500">No deposits found</p>
			} else {
				for _, deposit := range deposits {
					@DepositItem(deposit)
				}
			}
		</div>
		if totalPages > 1 {
			<div class="flex justify-between items-center mt-6">
				<div>
					<span class="text-sm text-gray-600">Page { fmt.Sprintf("%d of %d", page, totalPages) }</span>
				</div>
				<div class="flex space-x-2">
					if page > 1 {
						<button
							class="golem-button"
							hx-get={ prefixURL(pathPrefix, fmt.Sprintf("/dashboard/timeline?page=%d", page-1)) }
							hx-target="closest .golem-card"
							hx-swap="morphdom"
						>
							Previous
						</button>
					}
					if page < totalPages {
						<button
							class="golem-button"
							hx-get={ prefixURL(pathPrefix, fmt.Sprintf("/dashboard/timeline?page=%d", page+1)) }
							hx-target="closest .golem-card"
							hx-swap="morphdom"
						>
							Next
						</button>
					}
				</div>
			</div>
		}
	</div>
}

// UnmatchedDepositItem displays a single unmatched deposit
templ UnmatchedDepositItem(deposit UnmatchedDeposit) {
	<div class="timeline-item">
		<div class="golem-card border-l-4 border-amber-400">
			<div class="flex justify-between items-start mb-4">
				<div>
					<h3 class="text-lg font-semibold text-white">{ fmt.Sprintf("%.4f ETH", deposit.Amount) }</h3>
					<p class="text-sm text-white/70">From: { shortenAddress(deposit.FromAddress) }</p>
					<p class="text-sm text-white/70">To: { shortenAddress(deposit.ToAddress) }</p>
				</div>
				<div class="px-3 py-1 rounded-full bg-amber-500/20 border border-amber-400/40 text-amber-300 text-sm font-medium backdrop-blur-sm">
					Waiting: { formatTimeDiff(deposit.TimeSinceSeconds) }
				</div>
			</div>
			<div>
				<h4 class="text-xs font-medium text-white/60 uppercase mb-2 tracking-wider">L1 Deposit</h4>
				<p class="text-sm text-white/80 mb-1">Block: { fmt.Sprintf("%d", deposit.L1BlockNumber) }</p>
				<p class="text-sm text-white/80 mb-1">Time: { formatTime(deposit.L1Timestamp) }</p>
				<span class="text-sm text-blue-400 overflow-hidden text-ellipsis whitespace-nowrap block">
					Tx: { shortenAddress(deposit.TxHashL1) }
				</span>
			</div>
		</div>
	</div>
}

// DepositItem displays a single deposit
templ DepositItem(deposit DepositPair) {
	<div class="timeline-item">
		<div class="golem-card">
			<div class="flex justify-between items-start mb-4">
				<div>
					<h3 class="text-lg font-semibold text-white">{ fmt.Sprintf("%.4f ETH", deposit.Amount) }</h3>
					<p class="text-sm text-white/70">From: { shortenAddress(deposit.FromAddress) }</p>
					<p class="text-sm text-white/70">To: { shortenAddress(deposit.ToAddress) }</p>
				</div>
				<div class="px-3 py-1 rounded-full bg-green-500/20 border border-green-400/40 text-green-300 text-sm font-medium backdrop-blur-sm">
					{ formatTimeDiff(deposit.TimeDiffSeconds) }
				</div>
			</div>
			<div class="grid grid-cols-1 md:grid-cols-2 gap-4">
				<div>
					<h4 class="text-xs font-medium text-white/60 uppercase mb-2 tracking-wider">L1 Deposit</h4>
					<p class="text-sm text-white/80 mb-1">Block: { fmt.Sprintf("%d", deposit.L1BlockNumber) }</p>
					<p class="text-sm text-white/80 mb-1">Time: { formatTime(deposit.L1Timestamp) }</p>
					<span class="text-sm text-blue-400 overflow-hidden text-ellipsis whitespace-nowrap block">
						Tx: { shortenAddress(deposit.TxHashL1) }
					</span>
				</div>
				<div>
					<h4 class="text-xs font-medium text-white/60 uppercase mb-2 tracking-wider">L2 Confirmation</h4>
					<p class="text-sm text-white/80 mb-1">Block: { fmt.Sprintf("%d", deposit.L2BlockNumber) }</p>
					<p class="text-sm text-white/80 mb-1">Time: { formatTime(deposit.L2Timestamp) }</p>
					<span class="text-sm text-blue-400 overflow-hidden text-ellipsis whitespace-nowrap block">
						Tx: { shortenAddress(deposit.TxHashL2) }
					</span>
				</div>
			</div>
		</div>
	</div>
}

// TimeSeriesChart displays a chart of deposit time differences over time
templ TimeSeriesChart(pathPrefix string) {
	<div class="golem-card" hx-swap="morphdom">
		<h2 class="text-xl font-bold mb-4">Deposit Confirmation Times</h2>
		<div class="relative h-96">
			<canvas id="timeSeriesChart"></canvas>
		</div>
		<script src={ prefixURL(pathPrefix, "/static/js/chart.min.js") }></script>
		<script src={ prefixURL(pathPrefix, "/static/js/chartjs-adapter-date-fns.min.js") }></script>
		<script>
			// Chart instance to enable updates
			let timeSeriesChart;

			// Initialize the chart once
			function initializeChart() {
				const ctx = document.getElementById('timeSeriesChart');
				timeSeriesChart = new Chart(ctx, {
					type: 'line',
					data: {
						datasets: [{
							label: 'Confirmation Time (seconds)',
							data: [],
							backgroundColor: 'rgba(255, 255, 255, 0.2)',
							borderColor: '#ffffff',
							borderWidth: 3,
							pointStyle: 'circle',
							pointRadius: 4,
							pointBackgroundColor: '#ffffff',
							pointBorderColor: '#60a5fa',
							pointBorderWidth: 2,
							pointHoverRadius: 6,
							pointHoverBackgroundColor: '#fbbf24',
							pointHoverBorderColor: '#ffffff',
							tension: 0.05,
							fill: true
						}]
					},
					options: {
						responsive: true,
						maintainAspectRatio: false,
						plugins: {
							title: {
								display: false
							},
							legend: {
								display: false
							},
							tooltip: {
								backgroundColor: 'rgba(0, 0, 0, 0.8)',
								titleColor: '#ffffff',
								bodyColor: '#ffffff',
								borderColor: '#ffffff',
								borderWidth: 1,
								callbacks: {
									title: function(context) {
										// Simply format the x value directly
										if (context[0].parsed.x) {
											const date = new Date(context[0].parsed.x);
											return date.toLocaleString();
										}
										return '';
									}
								}
							}
						},
						scales: {
							y: {
								title: {
									display: true,
									text: 'Seconds',
									color: '#ffffff'
								},
								beginAtZero: true,
								ticks: {
									color: '#ffffff'
								},
								grid: {
									color: 'rgba(255, 255, 255, 0.2)'
								}
							},
							x: {
								type: 'time',
								time: {
									unit: 'hour',
									displayFormats: {
										hour: 'MMM d, HH:mm'
									},
									tooltipFormat: 'MMM d, yyyy HH:mm'
								},
								title: {
									display: true,
									text: 'Date',
									color: '#ffffff'
								},
								ticks: {
									color: '#ffffff'
								},
								grid: {
									color: 'rgba(255, 255, 255, 0.2)'
								}
							}
						}
					}
				});
			}

			// Function to fetch data and update the chart
			function updateChart() {
				fetch('{{ prefixURL(pathPrefix, "/api/chart-data") }}')
					.then(response => response.json())
					.then(data => {
						// Create dataset with proper timestamp objects
						const dataset = data.map(point => {
							return {
								x: new Date(point.timestamp),
								y: point.timeDiffSeconds
							};
						});

						// Update chart data without destroying the chart
						if (timeSeriesChart) {
							timeSeriesChart.data.datasets[0].data = dataset;
							timeSeriesChart.update();
						}
					})
					.catch(error => console.error('Error fetching chart data:', error));
			}

			// Initialize chart once
			initializeChart();
			
			// Initial data load
			updateChart();

			// Refresh data every 10 seconds
			setInterval(updateChart, 10000);
		</script>
	</div>
}
